---
layout: post
title: A Philosophy of Software Design
date: 2020-11-30
Author: Jack Zhu
tags: [computer-sciences, programming]
comments: true
---

There're a bunch of programming books that try to teach readers about how to write better code, e.g a few books from the famous *Robert Martin*, *Andrew Hunt*, etc. *A Philosophy of Software Design* is a good one among them, for its conciseness, focus, high-quality programming examples, and the best part is from the author's first-hand teaching experience in Standford University.

![philosophy](../images/philosophy.png)

Software development has been around for decades, and it's still difficult to find some good developers because most developers won't invest enough time in the design phase of a system, but start to implement as soon as he could without a very good design. Their excuses are justified by the tight sprint, or some mottos like *quick and dirty* or the fast-changing nature of software esp. for Internet products or start-ups. It makes sense to some degree, but in the long-run, it will be accumulated as so-called technical debt, which might become too big to pay later. Therefore it might be wiser to invest time in the early phase, i.e *strategic programming* instead of *tactical programming* as the author puts it. Those excuses could be traced back to the innate laziness of humans. After years' programming, we gained quite much experience, and once we encounter a problem which always looks familiar in some way, and we easily visit our experience and copy the design without giving a second thought at all, which might be good to some degree, or it might be out-of-date and become obsolete. In short, we just give up the design either by our laziness or by our proud growing experience.

Another important reason is from the culture. From the standpoint of the boss, what they care only is the output or delivery, and they believe *delivering the workable code is the key for the company's success*, while it's hard to measure the quality of the code, or no one bothers when the code works. And the compensation is measured by how you deliver things that work, not the hard-to-measure quality. And it leads to a dilemma that it's not wise to invest time to make it good but make it work in the shortest time possible even though the developer might want to have a good design in the first place.

So either we're too lazy or too self-conceited, or we are wise enough to pick the tactical mindset, we give up the chance of self-growing as a developer, and also the fun and joy of the developing. Designing a system is the most creative part of a project, which also means it's the most interesting and enjoyable part. And when it comes to implementation, it's still important but less exciting since it's to carry out the design and materialize them as code. Think about the outsourcing of the software industry, most programmers who work in an outsourcing project barely have the opportunity to change any design, which they lose the opportunity to grow themselves accordingly.

Hence, it's *wise* to follow the *strategic programming mindset* to benefit the system and the  company, and also benefit ourselves as a programmer.