---
layout: post
title: The Mythical Man Month and Other Essays on Software Engineering
date: 2021-08-09
Author: Jack Zhu
tags: [software-engineering, methodology]
comments: true
---

As a programmer or anyone who majored in *Computer Sciences*, this book won't look strange at all, at least you must have heard it many times if you haven't read it yet. I cannot remember when I I read it for the first time, but I still felt it was a great written masterpiece after my recent reading.

*Software engineering* is still new to some extent comparing to Mathematics or Physics. We count on decades while they count on centuries. Like other fields, once it gained a great advancement, there would always be a theory about how to do it better emerging, which is more a meta. It is not directly related to how to program, or how to structure a project, etc, but it more focuses on how to make a successful product(in a high level), what might be the boundary, how to improve productivity, what might be the different roles in a software project, different ways to develop a software, etc.

![engineering](../images/engineering.png)

Over the years since the genesis of the computer, things have changed remarkably and significantly. The *Moore's Law* was practiced to push the huge advancement of computer hardwares, which also pushed the software to evolve as fast as it could, even though in a slower pace. A lot of great softwares have been developed and used by millions of people and software becomes indispensable to everyone, esp. after the advent of the smart phones. In the meantime, wealth fell down to a lot of smart guys who could utilize the opportunity which are mostly related to software. This will also boost the research on how to improve the software engineering in turn.

*The Mythical Man Month* was firstly published in 1975 and it is almost half a century till now, but when we read the essays and a lot of the points still stand firmly, esp. after the update in the aniversary edition. Some of my takeaways will be listed below.

## Mythical Man Month

This has become so famous that you can always cite this phrase to rebut your manager who tries to add more manpower to meet the deadline of a delayed project. Though it is well-known and even acknowledged, in reality a lot of people still try to challenge it, which ended up not well normally.

The key thing here is about the initial cost by introducing more men, which includes the training cost, the communication cost, the collaboration cost, the re-arranging cost, etc. And this initial phase might be long and demorale the whole team to even delay the project further. But a lot of managers just don't count that and naively think the new men can magically fit into the team perfectly and immediately. With the initial cost accumulated, the project might become worse instead of better.

## No silver bullet (NSB)

The *Mythical Man Month* is part of NSB, and it is typically the first choice for the managers who try to *save* the project. Once it's found that adding more men won't solve the problem, more approaches will be explored and weighed. Once for a while, someone might come out and claim that he found the *silver bullet*, which is always a false claim.

For the over half a century that has passed, a lot of *silver bullets* have been proposed and some gained a lot of popularity while some became obsolete gradually.

Regarding software project management, we used to have *waterfall model*, *the iteration model*, *the agile manifesto*, and *the lean software development*. The new ones always contain some great points, e.g *embracing changes*, *standup meetings*, *CI/CD*, *the lead time*, etc.

About programming languages, we also have procedural language like C, and then the *object-oriented language* like C++, and the functional languages like Scala, Clojure, and some more dynamic and mixed languages like Python. Writing code becomes easier and a lot of difficult parts go to the compiler or interpreter which frees the programmers to be able to focus on the business.

And also programmers have to use an editor, whether it's a simple plain text editor and it's a full-featured modern IDE. Something like *intellisense* is surely a great boost to programmers' productivity to avoid typing the mundane block of code. And then we have Github's *copilot* powered by AI, which could *guess* what you might want to write next instead of pulling predefined code snippets. Finally, programmers could focus on the business.

Even with the above advancement, it's hard to say we have found the silver bullet to tackle the problem once for all. As the author stated in the book, the difficult lies in the complexity of software construction and the complexity grows bigger once we add more functions which is very normal.

----
I am deeply surprised that so many points still hold after many years, which makes this book a must-read for every programmer and software engineer. I have put the book on the very shelf where I will revisit very often, which doesn't have big room.